//////////////////////////////   Общие процедуры и функции   //////////////////////////////

// функция на основе данных переданных в параметре формирует параметры HTTPСоединение
//
// параметры:
//	ИмяСервиса, тип "строка" - имя сервиса к которому требуется подключение	
//	
// возвращаемое значение: новое HTTPСоединение 
//
Функция HTTPConnection(ИмяСервиса) Экспорт
	
	beta = Ложь;
	#Если Сервер И НЕ ТолстыйКлиентОбычноеПриложение Тогда
		УстановитьПривилегированныйРежим(истина);	
		beta = Константы.EFSOL_Beta.Получить();
		УстановитьПривилегированныйРежим(Ложь);	
	#КонецЕсли
	
	Если ИмяСервиса = "DelansMS" Тогда
		
		Порт = 443;
		Пользователь = "RemoteAccess";
		Пароль = "Efsol111";
		Прокси = Неопределено;
		Таймаут = 0;
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;

		Сервер = "localhost";
		Если beta Тогда
			Сервер = "beta-" + Сервер;
		КонецЕсли;
		
	ИначеЕсли ИмяСервиса = "apiModulbank" Тогда
		
		Порт = 443;
		Пользователь = "";
		Пароль = "";
		Таймаут = 0;
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
		Прокси = Неопределено;
		Сервер = "api.modulbank.ru";
		
	Иначе
		
		Порт = 80;
		Пользователь = "";
		Пароль = "";
		Прокси = Неопределено;
		Таймаут = 0;
		ЗащищенноеСоединение = Неопределено;
		
		Если ИмяСервиса = "ADL" Тогда
			Сервер = "adl.42clouds.com";
			Если beta Тогда
				Сервер = "beta." + Сервер;
			КонецЕсли;
		ИначеЕсли ИмяСервиса = "Recognition" Тогда
			Сервер = "recognition.42clouds.com";
		ИначеЕсли ИмяСервиса = "Core" Тогда
			Сервер = "core.42clouds.com";	
		ИначеЕсли ИмяСервиса = "MDM" Тогда
			Сервер = "mdm42.42clouds.com";
			Пользователь = "UserADL";
			Пароль = "tr158h2F3U";
		КонецЕсли;  
		
	КонецЕсли;
			
	НТТР = Новый HTTPСоединение(Сервер, Порт, Пользователь, Пароль, Прокси, Таймаут, ЗащищенноеСоединение); 

	Возврат НТТР;
	
КонецФункции

// функция парсинга XML ответа сервера, на основе анализа ответа сервера формируется структура
// с нужными параметрами из ответа сервера
//
// параметры:
//	ОтветСервера, тип "строка" - ответ сервера в виде XML строки		
//
// возвращаемое значение: структура с параметрми ответа сервера
//
Функция ПарсерОтветаXML(ОтветСервера) Экспорт
	
	ПараметрыОтвета = Новый Структура("КодОтвета, СтруктураОтвета", 200, Новый Структура);
	
	Если НЕ ОтветСервера = "" Тогда
		
		ОтветСервера = СтрЗаменить(ОтветСервера, "<result>", "<Result>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</result>", "</Result>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<result/>", "<Result/>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<request>", "<Request>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</request>", "</Request>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<request/>", "<Request/>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<error>", "<Error>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</error>", "</Error>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<error/>", "<Error/>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<code>", "<Code>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</code>", "</Code>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<code/>", "<Code/>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<description>", "<Description>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</description>", "</Description>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<description/>", "<Description/>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<debuginfo>", "<DebugInfo>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "</debuginfo>", "</DebugInfo>");
		ОтветСервера = СтрЗаменить(ОтветСервера, "<debuginfo/>", "<DebugInfo/>");
		
		Попытка
			ЧтениеXML = Новый ЧтениеXML;
			ЧтениеXML.УстановитьСтроку(ОтветСервера);
			
			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					КорневойЭлемент = ЧтениеXML.Имя;
					Пока ЧтениеXML.Прочитать() И НЕ (ЧтениеXML.Имя = КорневойЭлемент И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) Цикл
						Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
							ИмяЭлементаОтвета = ЧтениеXML.Имя;
							Если ЧтениеXML.ПервыйАтрибут() И ЧтениеXML.Имя = "Type" Тогда
								ТипЭлемента = ЧтениеXML.Значение
							Иначе
								ТипЭлемента = "String";
							КонецЕсли;
							Если ТипЭлемента = "List" Тогда 
								ЗначениеЭлементаОтвета = Новый Массив;
								Пока ЧтениеXML.Прочитать() И НЕ (ЧтениеXML.Имя = ИмяЭлементаОтвета И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) Цикл
									Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
										ЗначениеЭлементаОтвета.Добавить(ЧтениеXML.Значение);
									КонецЕсли;
								КонецЦикла;
							ИначеЕсли ТипЭлемента = "Table" Тогда 
								ЗначениеЭлементаОтвета = Новый Массив;
								Пока ЧтениеXML.Прочитать() И НЕ (ЧтениеXML.Имя = ИмяЭлементаОтвета И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) Цикл
									Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "Row" Тогда
										СтруктураСтроки = Новый Структура;
										Пока ЧтениеXML.Прочитать() И НЕ (ЧтениеXML.Имя = "Row" И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) Цикл
											Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
												ИмяКолонки = ЧтениеXML.Имя;
											ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
												Значение = ЧтениеXML.Значение;
												СтруктураСтроки.Вставить(ИмяКолонки, Значение);
											ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
												Если НЕ СтруктураСтроки.Свойство(ИмяКолонки) Тогда
													СтруктураСтроки.Вставить(ИмяКолонки, ""); 
												КонецЕсли;
											КонецЕсли;
										КонецЦикла;
										ЗначениеЭлементаОтвета.Добавить(СтруктураСтроки);
									КонецЕсли;
								КонецЦикла
							ИначеЕсли ТипЭлемента = "String" Тогда
								ЗначениеЭлементаОтвета = "";
								Пока ЧтениеXML.Прочитать() И НЕ (ЧтениеXML.Имя = ИмяЭлементаОтвета И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) Цикл
									Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
										ЗначениеЭлементаОтвета = ЧтениеXML.Значение;
									КонецЕсли;
								КонецЦикла
							КонецЕсли;
							ПараметрыОтвета.СтруктураОтвета.Вставить(ИмяЭлементаОтвета, ЗначениеЭлементаОтвета);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			Если ВРег(КорневойЭлемент) = ВРег("Error")Тогда
				Попытка
					ПараметрыОтвета.КодОтвета = Число(ПараметрыОтвета.СтруктураОтвета.Code);
				Исключение
					ПараметрыОтвета.КодОтвета = 400;
				КонецПопытки;
			ИначеЕсли НЕ (ВРег(КорневойЭлемент) = ВРег("Result") ИЛИ ВРег(КорневойЭлемент) = ВРег("Request")) Тогда
				ПараметрыОтвета.КодОтвета = 400;
			КонецЕсли;
		Исключение
			ПараметрыОтвета.КодОтвета = 400;
		КонецПопытки;
		
	Иначе
		ПараметрыОтвета.КодОтвета = 400;
	КонецЕсли;
	
	Если ПараметрыОтвета.КодОтвета = 400 И Не ПараметрыОтвета.СтруктураОтвета.Свойство("Code") Тогда
		Если Не ПараметрыОтвета.СтруктураОтвета.Свойство("Code") Тогда
			ПараметрыОтвета.СтруктураОтвета.Вставить("Code", Строка("400"));
		КонецЕсли;
		Если НЕ (ПараметрыОтвета.СтруктураОтвета.Свойство("Description") И ПараметрыОтвета.СтруктураОтвета.Свойство("DebugInfo")) Тогда
			ПараметрыОтвета.СтруктураОтвета.Вставить("DebugInfo", "The server's response does not meet the standard of service");
			ПараметрыОтвета.СтруктураОтвета.Вставить("Description", "Ответ сервера не соответствует стандарту сервиса");
		КонецЕсли;
	КонецЕсли;
	
	Если ВРег(КорневойЭлемент) = ВРег("Request") Тогда
		Возврат ПараметрыОтвета.СтруктураОтвета;
	Иначе
		Возврат ПараметрыОтвета;
	КонецЕсли;
	
КонецФункции

// функция выполняет запрос к серверу на основе информации переданной в параметрах
//
// параметры:
//	HTTPConnection, тип "HTTPСоединение" - соединение с сервером
//	АдресРесурса, тип "строка" - адрес запрашиваемого ресурса  
//	МетодОтправки, тип "строка" - метод отправки запроса (Get, Post, Post_File)
//	СтруктураПараметров, тип "строка" - если метод отправки "Post", то на основе этого параметра строится ContentDisposition
//	ПолноеИмяФайлаТела, тип "строка" - если метод отправки "Post_File", то параметр содержит полное имя файла
//	ПолучитьТелоКакДвоичныеДанные, тип "булево" - признак получения от сервера двоичных данных
//
// возвращаемое значение: структура, ответ сервера пропущенный через "ПарсерОтветаXML"
//
Функция ВыполнитьЗапрос(HTTPConnection, АдресРесурса, МетодОтправки = "Get", СтруктураПараметров=Неопределено, ПолноеИмяФайлаТела = Неопределено, ПолучитьТелоКакДвоичныеДанные = Ложь) Экспорт
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Accept", "text/xml");
	
	Запрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	
	Если Найти(АдресРесурса, "AccountUserSessions/Login") = 0 Тогда;
		#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ ТонкийКлиент ИЛИ ВебКлиент Тогда
			Token = EfsolТокен;
		#Иначе
			Token = ПараметрыСеанса.EfsolТокен;
			Если Token = "" Тогда
				 Token = "4BA62CD2-DF5F-4283-A7E6-6B741F8F4AC6";
			КонецЕсли;
		#КонецЕсли
		Заголовки.Вставить("Token", Token);
	КонецЕсли;
	
	Попытка 
		Если МетодОтправки = "Get" Тогда
			HTTPОтвет = HTTPConnection.Получить(Запрос);
			Если ПолучитьТелоКакДвоичныеДанные Тогда
				СтрокаContentDisposition = HTTPОтвет.Заголовки.Получить("Content-Disposition");
				Если СтрокаContentDisposition <> Неопределено Тогда
					СтруктураПараметровContentDisposition = ПарсерContentDisposition(СтрокаContentDisposition);
				КонецЕсли;
			КонецЕсли;
		Иначе 
			Если МетодОтправки = "Post_File" Тогда
				Заголовки.Вставить("Content-Disposition", СформироватьContentDisposition(СтруктураПараметров));
				Запрос.УстановитьИмяФайлаТела(ПолноеИмяФайлаТела); 
			ИначеЕсли МетодОтправки = "Post" Тогда
				Заголовки.Вставить("Content-Type", "application/xml");
				XMLЗапроса = СформироватьXMLЗапроса(СтруктураПараметров);
				Запрос.УстановитьТелоИзСтроки(XMLЗапроса);
			КонецЕсли;
			HTTPОтвет = HTTPConnection.ОтправитьДляОбработки(Запрос);
		КонецЕсли;
		ОтветСервера = HTTPОтвет.ПолучитьТелоКакСтроку();
	Исключение
		Причина = ОписаниеОшибки();
		ОтветСервера = "";
	КонецПопытки;
	
	Если ПолучитьТелоКакДвоичныеДанные И HTTPОтвет.КодСостояния = 200 Тогда
		ОтветСервераДвоичныеДанные = HTTPОтвет.ПолучитьТелоКакДвоичныеДанные();
		ПараметрыОтвета = Новый Структура("КодОтвета, СтруктураОтвета", 200, Новый Структура);
		ПараметрыОтвета.СтруктураОтвета.Вставить("ДвоичныеДанные", ОтветСервераДвоичныеДанные);
		ПараметрыОтвета.СтруктураОтвета.Вставить("ТелоОтветаСтрока", ОтветСервера);
		Если СтруктураПараметровContentDisposition <> Неопределено Тогда
			ПараметрыОтвета.Вставить("СтруктураПараметровContentDisposition", СтруктураПараметровContentDisposition);
		КонецЕсли;
	Иначе
		ПараметрыОтвета = ПарсерОтветаXML(ОтветСервера); 
	КонецЕсли;

	Возврат ПараметрыОтвета;
	
КонецФункции

Функция СформироватьContentDisposition(СтруктураПараметров) Экспорт
	
	ЗначениеContentDisposition = "attachment";
	Если СтруктураПараметров <> Неопределено Тогда
		Для Каждого Параметр Из СтруктураПараметров Цикл
			////преобразование в строку URL для значений, которые могут содержать кирилицу  при отправке для служб, работающих не в 1С
			////пока не используется
			//ЗначениеContentDisposition = ЗначениеContentDisposition + "; " + Параметр.Ключ + "*=""UTF-8''" + ПреобразоватьКURL(Параметр.Значение) + """";
			//
				ЗначениеContentDisposition = ЗначениеContentDisposition + "; " + Параметр.Ключ + "=""" + Параметр.Значение + """";
			
		КонецЦикла;
	КонецЕсли;
	
	Возврат ЗначениеContentDisposition;
	
КонецФункции

// функция формирования XML запроса (для передачи в теле ответа)
//
// параметры:
//	СтруктураХML, тип "структура" - структура xml, где ключ это xmlElementName, а значение это xmlElementValue
//
// возвращаемое значение: ЗаписьXML, где находится построеный XML 
//	
Функция СформироватьXMLЗапроса(СтруктураХML) Экспорт
		
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьОбъявлениеXML();
	
	Запись.ЗаписатьНачалоЭлемента("Request");
	Если СтруктураХML <> Неопределено Тогда	
		Для Каждого Элемент Из СтруктураХML Цикл
			Запись.ЗаписатьНачалоЭлемента(Элемент.Ключ);
			Если ТипЗнч(Элемент.Значение) = Тип("Массив") Тогда
				Запись.ЗаписатьАтрибут("Type","List");
				Массив = Элемент.Значение;
				Для Каждого ЭлементМассива Из Массив Цикл
					Запись.ЗаписатьНачалоЭлемента("item");
					Запись.ЗаписатьТекст(ЭлементМассива);
					Запись.ЗаписатьКонецЭлемента();
				КонецЦикла;
			//ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("ТаблицаЗначений") Тогда
			//	Запись.ЗаписатьАтрибут("type","table");
			//	ТаблицаЗначений = Элемент.Значение;
			//	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
			//		Запись.ЗаписатьНачалоЭлемента("row");
			//		Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			//			ИмяКолонки = Колонка.Имя;
			//			ЗначениеЯчейки = СтрокаТаблицы[ИмяКолонки];
			//			Запись.ЗаписатьНачалоЭлемента(ИмяКолонки);
			//			Запись.ЗаписатьТекст(ЗначениеЯчейки);
			//			Запись.ЗаписатьКонецЭлемента();
			//		КонецЦикла;
			//		Запись.ЗаписатьКонецЭлемента();
			//	КонецЦикла;
			Иначе
				Запись.ЗаписатьТекст(Элемент.Значение);	
			КонецЕсли;
			Запись.ЗаписатьКонецЭлемента();
		КонецЦикла;
	КонецЕсли;

	Запись.ЗаписатьКонецЭлемента();
	ТекстЗапросаXML = Запись.Закрыть();

	Возврат ТекстЗапросаXML;
	
КонецФункции

// функция анализирует XML и приводит значения данных XML к типам данных 1С 
//
// параметры:
//	СтруктураПараметров, тип "структура" -  структура параметров
//	СтруктураТиповПараметров, тип "структура" - структура типов параметров
//
// возвращаемое значение: СтруктураПреобразованныхДанных, тип "структура"
//
Функция ПолучитьXMLЗначенияДанных(СтруктураПараметров, СтруктураТиповПараметров) Экспорт
	
	СтруктураПреобразованныхДанных = Новый Структура;
	
	Для Каждого ЭлементТипаПараметра Из СтруктураТиповПараметров Цикл
		ПреобразованноеЗначение = Неопределено;
		
		Если СтруктураПараметров.Свойство(ЭлементТипаПараметра.Ключ) Тогда
			Попытка
				Если ЭлементТипаПараметра.Значение = "Дата" И Найти(СтруктураПараметров[ЭлементТипаПараметра.Ключ], "0001-01-01T00:00:00") <> 0 Тогда
					ПреобразованноеЗначение = '00010101000000';
				Иначе
					ПреобразованноеЗначение = XMLЗначение(Тип(ЭлементТипаПараметра.Значение), СтруктураПараметров[ЭлементТипаПараметра.Ключ]);
				КонецЕсли;
			Исключение
				Если Тип(ЭлементТипаПараметра.Значение) = "Булево" Тогда
					ПреобразованноеЗначение = Ложь;
				ИначеЕсли Тип(ЭлементТипаПараметра.Значение) = "Число" Тогда
					ПреобразованноеЗначение = 0;
				ИначеЕсли Тип(ЭлементТипаПараметра.Значение) = "Строка" Тогда
					ПреобразованноеЗначение = "";
				ИначеЕсли Тип(ЭлементТипаПараметра.Значение) = "Дата" Тогда
					ПреобразованноеЗначение = '00010101000000';
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		СтруктураПреобразованныхДанных.Вставить(ЭлементТипаПараметра.Ключ, ПреобразованноеЗначение); 
	КонецЦикла;
	
	Возврат СтруктураПреобразованныхДанных;
	
КонецФункции

// функция проверяет валидность текущего токена
Функция ПроверитьТокен() Экспорт
	
	#Если Сервер И НЕ ТолстыйКлиентОбычноеПриложение Тогда
		Token = ПараметрыСеанса.EfsolТокен;
	#Иначе
		Token = EfsolТокен;
	#КонецЕсли
	
	Если НЕ (Token = Неопределено ИЛИ Token = "") Тогда
	  	ErrorDescription = "";
		Результат = EfsolCoreКлиентСервер.AccountUserSessions_CheckTokenValidity(Token, ErrorDescription);
	КонецЕсли;
	
	Если Результат = Истина Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// функция парсинга заголовка "ContentDisposition"
//
// параметры:
//	СтрокаContentDisposition, тип "строка" - собственно и сам заголовок как строка	
//
// возвращаемое значение: структура параметров заголовка
//
Функция ПарсерContentDisposition(СтрокаContentDisposition) Экспорт
	
	СтруктураПараметров = Новый Структура;
	
	МассивСтрокПараметров = РазбитьСтроку(";", СтрокаContentDisposition);
	Для Каждого СтрокаПараметра Из МассивСтрокПараметров Цикл
		ПозицияРазделителя = Найти(СтрокаПараметра, "=");
		Если ПозицияРазделителя > 0 Тогда
			ИмяПараметра = Лев(СтрокаПараметра,ПозицияРазделителя-1); 
			ЗначениеПараметра = Сред(СтрокаПараметра, ПозицияРазделителя+1);
			ЗначениеПараметра = СтрЗаменить(ЗначениеПараметра, """", "");
			Попытка
				СтруктураПараметров.Вставить(ИмяПараметра,ЗначениеПараметра); 
			Исключение
			КонецПопытки;
		КонецЕсли;	
	КонецЦикла;
		
	Возврат СтруктураПараметров;
	
КонецФункции

// Функция разбивает строку по разделителям, лимит определяет максимальное количество слов
// аналог split в PHP
//
// параметры:
//	СимволыРазделители, тип "строка" - строка с символами разделителями
//	Строка, тип "строка" - строка для разбиения
//	Лимит, тип "число" - количество получаемых слов из строки
//
// возвращаемое значение: массив слов 
//
Функция РазбитьСтроку(СимволыРазделители, Строка, Лимит = Неопределено) Экспорт
	
	НоваяСтрока = Строка;
	МассивСлов = Новый Массив;
	ИщемНачало = Истина;
	ТекСлово = "";
	
	Для НомерСимволаСтроки = 1 по СтрДлина(Строка) цикл
		ТекСимвол = Сред(Строка,НомерСимволаСтроки,1);
		Если Найти(СимволыРазделители, ТекСимвол) = 0 Тогда
			ТекСлово = ТекСлово + ТекСимвол;
			ИщемНачало = Ложь;
			продолжить;
		ИначеЕсли ИщемНачало Тогда
			МассивСлов.Добавить("");
			Если МассивСлов.Количество() = Лимит Тогда
				Возврат МассивСлов;
			КонецЕсли;
			продолжить;
		Иначе
			МассивСлов.Добавить(ТекСлово);
			Если МассивСлов.Количество() = Лимит Тогда
				Возврат МассивСлов;
			КонецЕсли;
			ТекСлово = "";
			ИщемНачало = Истина;
		КонецЕсли;
	конеццикла;
	Если Не ИщемНачало Тогда
		МассивСлов.Добавить(СокрЛП(ТекСлово));
	КонецЕсли;
	
	Возврат МассивСлов;
	
конецфункции


///////////////////////////////////////////////////////////////////////
// Преобразование к URL

// функция предназначенная для преобразования числа в заданную систему исчисления
// 
// параметры:
//	Число10, тип "число" - число в десятичной системе исчисления
//	система, тип "число" - система исчисления, в которую нужно перевести число
//
// возвращаемое значение: СтрокаСистема - переведенное число или -1
//
Функция ПреобразоватьвСистему(Число10, система) 
	
	Если система > 36 или система < 2 тогда
		СообщениеПользователю = Новый СообщениеПользователю;
		СообщениеПользователю.Текст = "Выбранная система исчисления не поддерживается";
		СообщениеПользователю.Сообщить();
		Возврат -1;
	КонецЕсли;
	
	СтрокаЗначений = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	СтрокаСистема = "";
	Пока Число10 > 0 Цикл
		РезДеления = Число10 / система;
		ЧислоСистема = цел(РезДеления);
		остатокОтДеления = Число10 - система * (ЧислоСистема);
		СтрокаСистема = Сред(СтрокаЗначений, остатокОтДеления + 1, 1) + СтрокаСистема;
		Число10 = ?(ЧислоСистема = 0, 0, РезДеления); 
	КонецЦикла;
	
	Нечётное = стрДлина(СтрокаСистема) - цел(стрДлина(СтрокаСистема) / 2) * 2;
	Если Нечётное Тогда
		СтрокаСистема = "0" + СтрокаСистема;
	КонецЕсли;

	Возврат СтрокаСистема;
	
КонецФункции

// функция предназначенная для преобразования строки в стандарт URL
// 
// параметры:
//	Стр, тип "строка" - строка
//
// возвращаемое значение: строка в стандарте URL
//
Функция ПреобразоватьКURL(Стр) Экспорт
	
	Длина = СтрДлина(Стр);
	Итог = "";
	Для Н = 1 По Длина Цикл
		Знак = Сред(Стр, Н, 1);
		Код = КодСимвола(Знак);
		
		Если ((Знак >= "a") И (Знак <= "z")) ИЛИ
			 ((Знак >= "A") И (Знак <= "Z")) ИЛИ
			 ((Знак >= "0") И (Знак <= "9")) Тогда
			Итог = Итог + Знак;
		Иначе
			Если (Код >= КодСимвола("А")) И (Код <= КодСимвола("п")) Тогда
				Итог = Итог + "%" + ПреобразоватьвСистему(208, 16) + "%" + ПреобразоватьвСистему(144 + Код - КодСимвола("А"), 16);
			ИначеЕсли (Код >= КодСимвола("р")) И (Код <= КодСимвола("я")) Тогда
				Итог = Итог + "%" + ПреобразоватьвСистему(209, 16) + "%" + ПреобразоватьвСистему(128 + Код - КодСимвола("р"), 16);
			ИначеЕсли (Знак = "ё") Тогда
				Итог = Итог + "%" + ПреобразоватьвСистему(209, 16) + "%" + ПреобразоватьвСистему(145, 16);
			ИначеЕсли (Знак = "Ё") Тогда
				Итог = Итог + "%" + ПреобразоватьвСистему(208, 16) + "%" + ПреобразоватьвСистему(129, 16);
			Иначе
				Итог = Итог + "%" + ПреобразоватьвСистему(Код, 16);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Итог;
	
КонецФункции
